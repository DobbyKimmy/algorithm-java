## Lesson1
#### 时间复杂度与额外空间复杂度
##### 常数时间的操作
一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

##### 时间复杂度
时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作bigO)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

##### 几种常见的时间复杂度
- O(1)
- O(logN)
- O(N)
- O(N*logN)
- O(N ^ 2)
- O(N ^ 3)
- O(N ^ k)
- O(2 ^ N)
- O(3 ^ N)
- O(k ^ N)
- O(N!)

##### 额外空间复杂度
额外空间复杂度是指：要完成自己设计的算法流程，需要多少额外的空间

如果程序运行过程中，不需要额外的数据结构，只是使用了额外的几个变量。那么我们就说额外空间复杂度为O(1)

如果要申请一个和原数组大小一样的数组，那么额外空间复杂度为O(n)



#### 选择排序与冒泡排序
##### 选择排序
选择排序的思路非常简单：

对于一个长度为N的数组arr

首先，从index为0的位置遍历到N-1,找到这个范围内最小的那个数字的下标，然后让这个数字和arr[0]交换，arr[0]此时就已经排好了;

然后，从index为1的位置遍历到N-1,找到这个范围内最小的那个数字的下标，然后让这个数字和arr[1]交换，arr[1]此时就已经拍好了;

中间过程省略... 

直到，我们排好了所有的数字，这就是选择排序。


##### 选择排序代码实现
```java
public class SelectionSort {
    public void sort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                minIndex = arr[j] < arr[minIndex] ? j : minIndex;
            }
            swap(arr, i, minIndex);
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

```
选择排序的代码中，涉及到两次遍历循环，所以选择排序的时间复杂度为O(n ^ 2)

##### 冒泡排序
冒泡排序的思路一样非常简单

冒泡排序得名于泡泡从水中越往上浮越大；所以冒泡排序就是每次都将最大的数排到最后面去。

冒泡排序代码如下：

```java

public class BubbleSort {

    public void sort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }
    }
    
    private static void swap(int[] arr,int i,int j){
       arr[i] = arr[i] ^ arr[j];
       arr[j] = arr[i] ^ arr[j];
       arr[i] = arr[i] ^ arr[j];
    }
}

```
同样的，我们理清冒泡排序的流程后，也可以得出冒泡排序的时间复杂度为O(n ^ 2)

#### 插入排序

![](http://8.129.78.198/wp-content/uploads/2020/10/pokersort-300x225.jpg)

插入排序也叫做扑克牌排序(poker sort),它的思路和码扑克牌是一样的，从手中没有牌开始，我们一张一张将码到手里，每抓一张就让手中的所有牌有序，直到抓到最后一张牌。

插入排序的代码如下：
```java
public class InsertionSort {

    public void sort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // [5,4,1,3,2]
        for (int i = 1, j; i < arr.length; i++) {
            j = i;
            while (j > 0 && arr[j] < arr[j - 1]) {
                swap(arr, j, j - 1);
                j--;
            }
        }
    }
    
    private static void swap(int[] arr,int i,int j){
       arr[i] = arr[i] ^ arr[j];
       arr[j] = arr[i] ^ arr[j];
       arr[i] = arr[i] ^ arr[j];
    }
}

```
对于插入排序的时间复杂度分析就不是那么简单了；

试想一下，如果待排序的数组为：`[1,2,3,4,5]`

那么插入排序就是一个O(N)的时间复杂度的排序算法

相反，如果待排序的数组为：`[5,4,3,2,1]`

那么，插入排序就是一个O(N ^ 2)的时间复杂度的排序算法

也就是说：

不同于选择排序和冒泡排序，前两者的排序算法是一个固定的值，无论数据状况如何，它们的时间复杂度均为O(N ^ 2);而插入排序的时间复杂度和数据情况有关，它的实际的时间复杂度在O(N) ~ O(N ^ 2)之间；不过，算法流程要按照**最差的情况**来估计时间复杂度；所以，插入排序的时间复杂度我们还是要看作O(N ^ 2)


#### 二分法的详解与扩展
二分法的时间复杂度为：log(N)；

经典问题：

1. 在一个有序数组中，找某个数是否存在
2. 在一个有序数组中，找`>=`某个数最左侧的位置
3. 局部最小值问题


#### 异或运算的性质与扩展

1. `0^N==N`; `N^N==0`
2. 异或运算满足交换律和结合率
3. 不用额外变量交换两个数
4. 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数
5. 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数

#### 对数器
1. 有一个你想要测的方法a
2. 实现复杂度不好但是容易实现的方法b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确

#### 剖析递归
用递归方法找一个数组中的最大值，系统上到底是怎么做的？

master公式的使用
```
T(N)=a*T(N/b)+O(N^d)
```

1. `log(b,a)>d`->复杂度为O(N^log(b,a))
2. `log(b,a)=d`->复杂度为O(N^d*logN)
3. `log(b,a)<d`->复杂度为O(N^d)
4. [补充阅读](www.gocalf.com/blog/algorithm-complexity-and-master-theorem.html)
